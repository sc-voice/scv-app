#!/usr/bin/env swift

import Foundation
import SQLite3

let fileManager = FileManager.default
let startTime = Date()

// Paths
let projectRoot = ProcessInfo.processInfo.environment["PROJECT_ROOT"] ??
  URL(fileURLWithPath: #file).deletingLastPathComponent().deletingLastPathComponent().path
let translationDir = "\(projectRoot)/local/ebt-data/translation"
let authorFilePath = "\(projectRoot)/local/ebt-data/_author.json"
let buildDir = "\(projectRoot)/local/build"
let resourcesDir = "\(projectRoot)/scv-core/Sources/Resources"

// Ensure build and Resources directories exist
try? fileManager.createDirectory(atPath: buildDir, withIntermediateDirectories: true)
try? fileManager.createDirectory(atPath: resourcesDir, withIntermediateDirectories: true)

// Load author information from _author.json
var authorDict: [String: [String: Any]] = [:]
if let authorData = try? Data(contentsOf: URL(fileURLWithPath: authorFilePath)) {
  if let dict = try? JSONSerialization.jsonObject(with: authorData) as? [String: [String: Any]] {
    authorDict = dict
  }
}

// Get git hash from ebt-data repo if available
func getEbtDataGitHash() -> String? {
  let task = Process()
  task.launchPath = "/bin/bash"
  task.arguments = ["-c", "cd \(projectRoot)/local/ebt-data && git rev-parse HEAD 2>/dev/null"]
  let pipe = Pipe()
  task.standardOutput = pipe
  do {
    try task.run()
    task.waitUntilExit()
    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    if let hash = String(data: data, encoding: .utf8)?.trimmingCharacters(in: .whitespacesAndNewlines) {
      return hash.isEmpty ? nil : hash
    }
  } catch {
    return nil
  }
  return nil
}

let gitHash = getEbtDataGitHash()

// Show help if no args provided
if CommandLine.arguments.count <= 1 {
  print("""
  Build per-author SQLite databases for SC-Voice

  USAGE:
    build-ebt-data <lang:author> [<lang:author> ...]

  EXAMPLES:
    build-ebt-data en:sujato
    build-ebt-data en:sujato de:sabbamitta
    build-ebt-data fr:sekha it:giovannizappa

  AVAILABLE AUTHORS:
    English (en): brahmali, kelly, kovilo, soma, suddhaso, sujato
    German (de): sabbamitta
    French (fr): christelle, noeismet, sekha, wijayaratna
    Italian (it): giovannizappa
    + many others...

  OUTPUT:
    Intermediate databases (.db) are built to: local/build/ebt-<lang>-<author>.db
    Compressed databases (.zst) are output to: scv-core/Sources/Resources/ebt-<lang>-<author>.db.zst
  """)
  exit(0)
}

// Parse command-line arguments
var selectedAuthors: [(lang: String, author: String)] = []
var listMetadata: (lang: String, author: String)? = nil
var buildManifest = false

let args = CommandLine.arguments.dropFirst()
var i = args.startIndex
while i < args.endIndex {
  let arg = args[i]

  if arg == "build-manifest" {
    buildManifest = true
  } else if arg == "--list-metadata" {
    i = args.index(after: i)
    guard i < args.endIndex else {
      print("ERROR: --list-metadata requires lang:author argument")
      exit(1)
    }
    let parts = args[i].split(separator: ":").map(String.init)
    guard parts.count == 2 else {
      print("ERROR: Invalid format '\(args[i])'. Expected 'lang:author'")
      exit(1)
    }
    listMetadata = (lang: parts[0], author: parts[1])
  } else {
    let parts = arg.split(separator: ":").map(String.init)
    if parts.count == 2 {
      selectedAuthors.append((lang: parts[0], author: parts[1]))
    } else {
      print("ERROR: Invalid format '\(arg)'. Expected 'lang:author' or --list-metadata lang:author")
      print("Example: build-ebt-data en:sujato de:sabbamitta")
      print("Example: build-ebt-data --list-metadata en:brahmali")
      exit(1)
    }
  }
  i = args.index(after: i)
}

// Helper function to count translation files for an author (recursive)
func countTranslationFiles(lang: String, author: String) -> Int {
  let suttaPath = "\(translationDir)/\(lang)/\(author)/sutta"
  let vinayaPath = "\(translationDir)/\(lang)/\(author)/vinaya"

  var count = 0

  // Count sutta files recursively
  if fileManager.fileExists(atPath: suttaPath) {
    let suttaFiles = findJSONFiles(inDirectory: suttaPath)
    count += suttaFiles.count
  }

  // Count vinaya files recursively
  if fileManager.fileExists(atPath: vinayaPath) {
    let vinayaFiles = findJSONFiles(inDirectory: vinayaPath)
    count += vinayaFiles.count
  }

  return count
}

// Handle build-manifest command
if buildManifest {
  print("Building db-manifest.json...")

  // Find all .db files in local/build
  guard let buildFiles = try? fileManager.contentsOfDirectory(atPath: buildDir) else {
    print("ERROR: Cannot read build directory at \(buildDir)")
    exit(1)
  }

  var manifestDatabases: [[String: Any]] = []

  for file in buildFiles.sorted() {
    guard file.hasPrefix("ebt-") && file.hasSuffix(".db") else { continue }

    // Extract lang and author from filename: ebt-{lang}-{author}.db
    let parts = file.dropFirst(4).dropLast(3).split(separator: "-")
    guard parts.count >= 2 else { continue }

    let lang = String(parts[0])
    let author = parts.dropFirst().joined(separator: "-")
    let dbPath = "\(buildDir)/\(file)"
    let zstPath = "\(resourcesDir)/ebt-\(lang)-\(author).db.zst"

    // Check if corresponding .zst exists
    guard fileManager.fileExists(atPath: zstPath) else {
      print("WARNING: No .zst found for \(file), skipping")
      continue
    }

    // Count translation files
    let fileCount = countTranslationFiles(lang: lang, author: author)

    // Compare timestamps
    do {
      let dbAttrs = try fileManager.attributesOfItem(atPath: dbPath)
      let zstAttrs = try fileManager.attributesOfItem(atPath: zstPath)

      if let dbModDate = dbAttrs[.modificationDate] as? Date,
         let zstModDate = zstAttrs[.modificationDate] as? Date {
        let timeDiffSeconds = abs(dbModDate.timeIntervalSince(zstModDate))
        let timeDiffHours = timeDiffSeconds / 3600

        if timeDiffHours > 1 {
          print("WARNING: ebt-\(lang)-\(author).db and .db.zst timestamps differ by \(String(format: "%.1f", timeDiffHours))h - metadata may be stale")
        }
      }
    } catch {
      print("WARNING: Cannot compare timestamps for \(file): \(error)")
    }

    // Extract metadata from .db
    var db: OpaquePointer?
    guard sqlite3_open(dbPath, &db) == SQLITE_OK else {
      print("ERROR: Cannot open database at \(dbPath)")
      exit(1)
    }
    defer { sqlite3_close(db) }

    let query = "SELECT language, author, author_name, git_hash, build_timestamp, files, json FROM metadata LIMIT 1"
    var stmt: OpaquePointer?
    guard sqlite3_prepare_v2(db, query, -1, &stmt, nil) == SQLITE_OK else {
      print("ERROR: Cannot prepare query for \(file)")
      continue
    }
    defer { sqlite3_finalize(stmt) }

    if sqlite3_step(stmt) == SQLITE_ROW {
      if let langC = sqlite3_column_text(stmt, 0),
         let authorC = sqlite3_column_text(stmt, 1),
         let authorNameC = sqlite3_column_text(stmt, 2),
         let buildTimestampC = sqlite3_column_text(stmt, 4) {

        let dbFiles = Int(sqlite3_column_int(stmt, 5))

        var metaDict: [String: Any] = [
          "language": String(cString: langC),
          "author": String(cString: authorC),
          "authorName": String(cString: authorNameC),
          "buildTimestamp": String(cString: buildTimestampC),
          "files": dbFiles,
        ]

        // Optional git_hash
        if sqlite3_column_type(stmt, 3) != SQLITE_NULL,
           let gitHashC = sqlite3_column_text(stmt, 3) {
          metaDict["gitHash"] = String(cString: gitHashC)
        }

        // Optional json
        if sqlite3_column_type(stmt, 6) != SQLITE_NULL,
           let jsonC = sqlite3_column_text(stmt, 6) {
          metaDict["json"] = String(cString: jsonC)
        }

        manifestDatabases.append(metaDict)
      }
    }
  }

  // Write manifest.json
  let manifest: [String: Any] = ["databases": manifestDatabases]
  guard let jsonData = try? JSONSerialization.data(withJSONObject: manifest, options: .prettyPrinted) else {
    print("ERROR: Cannot serialize manifest to JSON")
    exit(1)
  }

  let manifestPath = "\(resourcesDir)/db-manifest.json"
  do {
    try jsonData.write(to: URL(fileURLWithPath: manifestPath))
    print("SUCCESS: Written db-manifest.json with \(manifestDatabases.count) databases")
    print("  Manifest: \(manifestPath)")
  } catch {
    print("ERROR: Cannot write manifest.json: \(error)")
    exit(1)
  }

  exit(0)
}

// Handle --list-metadata flag
if let meta = listMetadata {
  let dbPath = "\(buildDir)/ebt-\(meta.lang)-\(meta.author).db"

  var db: OpaquePointer?
  guard sqlite3_open(dbPath, &db) == SQLITE_OK else {
    print("ERROR: Cannot open database at \(dbPath)")
    exit(1)
  }
  defer { sqlite3_close(db) }

  let query = "SELECT language, author, author_name, git_hash, build_timestamp, files, json FROM metadata WHERE language = ? AND author = ?"
  var stmt: OpaquePointer?
  guard sqlite3_prepare_v2(db, query, -1, &stmt, nil) == SQLITE_OK else {
    print("ERROR: Cannot prepare query")
    exit(1)
  }
  defer { sqlite3_finalize(stmt) }

  sqlite3_bind_text(stmt, 1, (meta.lang as NSString).utf8String, -1, nil)
  sqlite3_bind_text(stmt, 2, (meta.author as NSString).utf8String, -1, nil)

  if sqlite3_step(stmt) == SQLITE_ROW {
    let language = String(cString: sqlite3_column_text(stmt, 0))
    let author = String(cString: sqlite3_column_text(stmt, 1))
    let authorName = String(cString: sqlite3_column_text(stmt, 2))
    let gitHash = String(cString: sqlite3_column_text(stmt, 3))
    let buildTimestamp = String(cString: sqlite3_column_text(stmt, 4))
    let files = Int(sqlite3_column_int(stmt, 5))

    print("Metadata for \(language):\(author)")
    print("  Source: \(dbPath)")
    print("  Author Name: \(authorName)")
    print("  Files: \(files)")
    print("  Git Hash: \(gitHash)")
    print("  Build Timestamp: \(buildTimestamp)")

    if sqlite3_column_type(stmt, 6) != SQLITE_NULL {
      let jsonStr = String(cString: sqlite3_column_text(stmt, 6))
      print("  JSON Metadata: \(jsonStr)")
    } else {
      print("  JSON Metadata: (none)")
    }
  } else {
    print("ERROR: No metadata found for \(meta.lang):\(meta.author)")
    exit(1)
  }

  exit(0)
}

if selectedAuthors.isEmpty {
  print("ERROR: No databases specified for building")
  exit(1)
}

print("Building selected databases: \(selectedAuthors.map { "\($0.lang)/\($0.author)" }.joined(separator: ", "))")

// Schema - segment-level indexing with metadata table
let schema = """
CREATE TABLE metadata (
  language TEXT,
  author TEXT,
  author_name TEXT,
  git_hash TEXT,
  build_timestamp TEXT,
  files INTEGER,
  json TEXT,
  PRIMARY KEY (language, author)
);

CREATE TABLE suttas (
  sutta_key TEXT PRIMARY KEY,
  total_segments INTEGER
);

CREATE TABLE segments (
  sutta_key TEXT,
  segment_id TEXT,
  segment_text TEXT
);

CREATE VIRTUAL TABLE segments_fts USING fts5(
  sutta_key UNINDEXED,
  segment_id UNINDEXED,
  segment_text
);

CREATE TRIGGER segments_ai AFTER INSERT ON segments BEGIN
  INSERT INTO segments_fts(sutta_key, segment_id, segment_text)
  VALUES (new.sutta_key, new.segment_id, new.segment_text);
END;
"""

// Recursive function to find all JSON files
func findJSONFiles(inDirectory dir: String) -> [String] {
  var files: [String] = []
  guard let contents = try? fileManager.contentsOfDirectory(atPath: dir) else {
    return files
  }

  for item in contents {
    let itemPath = "\(dir)/\(item)"
    var isDir: ObjCBool = false
    if fileManager.fileExists(atPath: itemPath, isDirectory: &isDir) {
      if isDir.boolValue {
        files.append(contentsOf: findJSONFiles(inDirectory: itemPath))
      } else if item.hasSuffix(".json") {
        files.append(itemPath)
      }
    }
  }
  return files
}

// Build timestamp
let dateFormatter = ISO8601DateFormatter()
let buildTimestamp = dateFormatter.string(from: Date())

// Collections
let collections = ["an", "dn", "kn", "mn", "sn"]

// Discover language/author combinations
var totalSuttas = 0
var totalSegments = 0
var builtCount = 0

guard let languages = try? fileManager.contentsOfDirectory(atPath: translationDir) else {
  print("ERROR: Cannot read translation directory")
  exit(1)
}

for language in languages.sorted() {
  let langPath = "\(translationDir)/\(language)"
  var isDir: ObjCBool = false
  guard fileManager.fileExists(atPath: langPath, isDirectory: &isDir), isDir.boolValue else {
    continue
  }

  guard let authors = try? fileManager.contentsOfDirectory(atPath: langPath) else {
    continue
  }

  for author in authors.sorted() {
    // Skip if this author not selected
    let isSelected = selectedAuthors.contains { $0.lang == language && $0.author == author }
    if !isSelected {
      continue
    }

    let authorPath = "\(langPath)/\(author)"
    guard fileManager.fileExists(atPath: authorPath, isDirectory: &isDir), isDir.boolValue else {
      continue
    }

    let dbPath = "\(buildDir)/ebt-\(language)-\(author).db"
    try? fileManager.removeItem(atPath: dbPath)

    print("  Building ebt-\(language)-\(author).db...")

    // SQLite3 setup for this author
    var db: OpaquePointer?
    guard sqlite3_open(dbPath, &db) == SQLITE_OK else {
      print("  ERROR: Cannot open database at \(dbPath)")
      continue
    }

    defer { sqlite3_close(db) }

    // Create schema
    var errorMessage: UnsafeMutablePointer<CChar>?
    if sqlite3_exec(db, schema, nil, nil, &errorMessage) != SQLITE_OK {
      let message = String(cString: errorMessage!)
      print("  ERROR: Schema creation failed: \(message)")
      sqlite3_free(errorMessage)
      continue
    }

    // Count translation files for this author
    let authorFileCount = countTranslationFiles(lang: language, author: author)

    // Insert metadata
    let metadataStatement = "INSERT INTO metadata (language, author, author_name, git_hash, build_timestamp, files, json) VALUES (?, ?, ?, ?, ?, ?, ?)"
    var metadataStmt: OpaquePointer?
    guard sqlite3_prepare_v2(db, metadataStatement, -1, &metadataStmt, nil) == SQLITE_OK else {
      print("  ERROR: Cannot prepare metadata statement")
      continue
    }

    let authorName = (authorDict[author]?["name"] as? String) ?? author
    var jsonString: String? = nil
    if let authorInfo = authorDict[author] {
      if let jsonData = try? JSONSerialization.data(withJSONObject: authorInfo),
         let jsonStr = String(data: jsonData, encoding: .utf8) {
        jsonString = jsonStr
      }
    }

    sqlite3_bind_text(metadataStmt, 1, (language as NSString).utf8String, -1, nil)
    sqlite3_bind_text(metadataStmt, 2, (author as NSString).utf8String, -1, nil)
    sqlite3_bind_text(metadataStmt, 3, (authorName as NSString).utf8String, -1, nil)
    if let hash = gitHash {
      sqlite3_bind_text(metadataStmt, 4, (hash as NSString).utf8String, -1, nil)
    } else {
      sqlite3_bind_null(metadataStmt, 4)
    }
    sqlite3_bind_text(metadataStmt, 5, (buildTimestamp as NSString).utf8String, -1, nil)
    sqlite3_bind_int(metadataStmt, 6, Int32(authorFileCount))
    if let jsonStr = jsonString {
      sqlite3_bind_text(metadataStmt, 7, (jsonStr as NSString).utf8String, -1, nil)
    } else {
      sqlite3_bind_null(metadataStmt, 7)
    }

    if sqlite3_step(metadataStmt) != SQLITE_DONE {
      print("  ERROR: Metadata insert failed")
      sqlite3_finalize(metadataStmt)
      continue
    }
    sqlite3_finalize(metadataStmt)

    // Prepare insert statements
    let insertSuttaStatement = "INSERT OR IGNORE INTO suttas (sutta_key, total_segments) VALUES (?, ?)"
    let insertSegmentStatement = "INSERT INTO segments (sutta_key, segment_id, segment_text) VALUES (?, ?, ?)"

    var suttaStmt: OpaquePointer?
    var segmentStmt: OpaquePointer?

    guard sqlite3_prepare_v2(db, insertSuttaStatement, -1, &suttaStmt, nil) == SQLITE_OK,
          sqlite3_prepare_v2(db, insertSegmentStatement, -1, &segmentStmt, nil) == SQLITE_OK else {
      print("  ERROR: Cannot prepare insert statements")
      continue
    }

    defer {
      sqlite3_finalize(suttaStmt)
      sqlite3_finalize(segmentStmt)
    }

    var authorSuttas = 0
    var authorSegments = 0

    // Process both sutta and vinaya directories
    let docDirs = ["sutta", "vinaya"]
    for docDir in docDirs {
      let docPath = "\(authorPath)/\(docDir)"
      guard fileManager.fileExists(atPath: docPath) else {
        continue
      }

      // Process all JSON files in docDir (includes subdirectories)
      let jsonFiles = findJSONFiles(inDirectory: docPath)

      for filePath in jsonFiles.sorted() {
        let fileName = URL(fileURLWithPath: filePath).lastPathComponent

        // Extract SCID from filename: "mn1_translation-en-sujato.json" → "mn1"
        let baseName = (fileName as NSString).deletingPathExtension
        let components = baseName.split(separator: "_").map(String.init)
        guard let scid = components.first else {
          continue
        }

        let suttaKey = "\(language)/\(author)/\(scid)"

        // Read JSON file
        guard let jsonData = try? Data(contentsOf: URL(fileURLWithPath: filePath)) else {
          continue
        }

        // Parse JSON to extract segments
        guard let jsonObject = try? JSONSerialization.jsonObject(with: jsonData) as? [String: Any] else {
          continue
        }

        let segmentCount = jsonObject.count

        // Insert sutta
        sqlite3_bind_text(suttaStmt, 1, (suttaKey as NSString).utf8String, -1, nil)
        sqlite3_bind_int(suttaStmt, 2, Int32(segmentCount))

        if sqlite3_step(suttaStmt) != SQLITE_DONE {
          print("  ERROR: Insert failed for sutta \(suttaKey)")
          continue
        }
        sqlite3_reset(suttaStmt)
        authorSuttas += 1

        // Insert segments
        for (segmentId, value) in jsonObject.sorted(by: { $0.key < $1.key }) {
          let segmentText: String
          if let stringValue = value as? String {
            segmentText = stringValue
          } else if let numberValue = value as? NSNumber {
            segmentText = numberValue.stringValue
          } else {
            continue
          }

          sqlite3_bind_text(segmentStmt, 1, (suttaKey as NSString).utf8String, -1, nil)
          sqlite3_bind_text(segmentStmt, 2, (segmentId as NSString).utf8String, -1, nil)
          sqlite3_bind_text(segmentStmt, 3, (segmentText as NSString).utf8String, -1, nil)

          if sqlite3_step(segmentStmt) != SQLITE_DONE {
            continue
          }
          sqlite3_reset(segmentStmt)
          authorSegments += 1
        }
      }
    }

    let dbSize = try? fileManager.attributesOfItem(atPath: dbPath)[.size] as? Int ?? 0
    let dbSizeMB = Double(dbSize ?? 0) / 1_000_000

    print("    ✓ \(authorSuttas) suttas, \(authorSegments) segments (\(String(format: "%.1f", dbSizeMB)) MB)")

    // Compress database to .zst
    let zstPath = "\(resourcesDir)/ebt-\(language)-\(author).db.zst"
    try? fileManager.removeItem(atPath: zstPath)

    let process = Process()
    process.launchPath = "/bin/bash"
    process.arguments = ["-c", "/opt/homebrew/bin/zstd -f -o \(zstPath) \(dbPath)"]
    do {
      try process.run()
      process.waitUntilExit()

      if process.terminationStatus == 0 {
        if let zstSize = try? fileManager.attributesOfItem(atPath: zstPath)[.size] as? Int {
          let zstSizeMB = Double(zstSize) / 1_000_000
          let ratio = (Double(dbSize ?? 1) - Double(zstSize)) / Double(dbSize ?? 1) * 100
          print("    ✓ Compressed to \(String(format: "%.1f", zstSizeMB)) MB (\(String(format: "%.0f", ratio))% reduction)")
        }
      } else {
        print("    ERROR: zstd compression failed")
      }
    } catch {
      print("    ERROR: Failed to run zstd compression: \(error)")
    }

    totalSuttas += authorSuttas
    totalSegments += authorSegments
    builtCount += 1
  }
}

let elapsed = Date().timeIntervalSince(startTime)

print("\nSUCCESS: Built \(builtCount) author databases")
print("  Total: \(totalSuttas) suttas, \(totalSegments) segments")
print("  Time elapsed: \(String(format: "%.2f", elapsed))s")
