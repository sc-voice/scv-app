#!/usr/bin/env swift

import Foundation

enum VersionBumpType: String {
    case major, minor, patch

    func bump(version: String) -> String {
        let parts = version.split(separator: ".", omittingEmptySubsequences: false).map { String($0) }
        var major = Int(parts.first ?? "0") ?? 0
        var minor = parts.count > 1 ? (Int(parts[1]) ?? 0) : 0
        var patch = parts.count > 2 ? (Int(parts[2]) ?? 0) : 0

        switch self {
        case .major:
            major += 1
            minor = 0
            patch = 0
        case .minor:
            minor += 1
            patch = 0
        case .patch:
            patch += 1
        }

        return "\(major).\(minor).\(patch)"
    }
}

let currentDir = FileManager.default.currentDirectoryPath
let versionSwiftPath = currentDir + "/scv-core/Sources/Version.swift"
let pbxprojPath = currentDir + "/scv-demo-ios/scv-demo-ios.xcodeproj/project.pbxproj"

guard FileManager.default.fileExists(atPath: versionSwiftPath) else {
    print("Error: Version.swift not found at \(versionSwiftPath)")
    exit(1)
}

guard FileManager.default.fileExists(atPath: pbxprojPath) else {
    print("Error: project.pbxproj not found at \(pbxprojPath)")
    exit(1)
}

// Parse arguments
let args = Array(CommandLine.arguments.dropFirst())
guard args.count > 0 else {
    print("Usage: version.swift [major|minor|patch]")
    exit(1)
}

guard let bumpType = VersionBumpType(rawValue: args[0]) else {
    print("Error: invalid version type '\(args[0])'. Use 'major', 'minor', or 'patch'")
    exit(1)
}

do {
    // Read current version from Version.swift
    var versionSwiftContent = try String(contentsOfFile: versionSwiftPath, encoding: .utf8)

    // Extract version using regex: public let appVersion = "X.Y.Z"
    let versionPattern = "public let appVersion = \"([\\d.]+)\""
    let versionRegex = try NSRegularExpression(pattern: versionPattern, options: [])
    let versionMatches = versionRegex.matches(in: versionSwiftContent, options: [], range: NSRange(versionSwiftContent.startIndex..., in: versionSwiftContent))

    guard let versionMatch = versionMatches.first,
          let versionRange = Range(versionMatch.range(at: 1), in: versionSwiftContent) else {
        print("Error: Could not find version in Version.swift")
        exit(1)
    }

    let currentVersion = String(versionSwiftContent[versionRange])
    let newVersion = bumpType.bump(version: currentVersion)

    // Update Version.swift
    versionSwiftContent.replaceSubrange(versionRange, with: newVersion)
    try versionSwiftContent.write(toFile: versionSwiftPath, atomically: true, encoding: .utf8)

    // Update pbxproj
    var pbxContent = try String(contentsOfFile: pbxprojPath, encoding: .utf8)
    let pbxPattern = "CURRENT_PROJECT_VERSION = ([\\d.]+);"
    let pbxRegex = try NSRegularExpression(pattern: pbxPattern, options: [])
    let pbxMatches = pbxRegex.matches(in: pbxContent, options: [], range: NSRange(pbxContent.startIndex..., in: pbxContent))

    if !pbxMatches.isEmpty {
        // Process matches in reverse order to avoid index shifting
        for match in pbxMatches.reversed() {
            if let versionRange = Range(match.range(at: 1), in: pbxContent) {
                pbxContent.replaceSubrange(versionRange, with: newVersion)
            }
        }
        try pbxContent.write(toFile: pbxprojPath, atomically: true, encoding: .utf8)
    }

    print("âœ“ Version bumped to \(newVersion)")

} catch {
    print("Error: \(error.localizedDescription)")
    exit(1)
}
